/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useEffect, useRef, useState } from "react";
import { useAnimations, useFBX, useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import {
  useCurrentAnimation,
  useCurrentSection,
  useIsMobile,
  useIsWireFrame,
} from "@/app/data/atoms";

import { motion } from "framer-motion-3d";
import { Variants } from "framer-motion";
import { useFrame, useThree } from "@react-three/fiber";

type GLTFResult = GLTF & {
  nodes: {
    EyeLeft: THREE.SkinnedMesh;
    EyeRight: THREE.SkinnedMesh;
    Wolf3D_Head: THREE.SkinnedMesh;
    Wolf3D_Teeth: THREE.SkinnedMesh;
    Wolf3D_Body: THREE.SkinnedMesh;
    Wolf3D_Outfit_Bottom: THREE.SkinnedMesh;
    Wolf3D_Outfit_Footwear: THREE.SkinnedMesh;
    Wolf3D_Outfit_Top: THREE.SkinnedMesh;
    Wolf3D_Hair: THREE.SkinnedMesh;
    Hips: THREE.Bone;
  };
  materials: {
    Wolf3D_Eye: THREE.MeshStandardMaterial;
    Wolf3D_Skin: THREE.MeshStandardMaterial;
    Wolf3D_Teeth: THREE.MeshStandardMaterial;
    Wolf3D_Body: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Bottom: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Footwear: THREE.MeshStandardMaterial;
    Wolf3D_Outfit_Top: THREE.MeshStandardMaterial;
    Wolf3D_Hair: THREE.MeshStandardMaterial;
  };
};

export function Avatar(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/models/avatar.glb") as GLTFResult;

  const { animations: idleAnimation } = useFBX("animations/Idle.fbx");
  idleAnimation[0].name = "Idle";

  const { animations: typingAnimation } = useFBX("animations/Typing.fbx");
  typingAnimation[0].name = "Typing";

  const { animations: fallingAnimation } = useFBX("animations/Falling.fbx");
  fallingAnimation[0].name = "Falling";

  const avatarRef = useRef<THREE.Group>(null);

  const { actions } = useAnimations(
    [idleAnimation[0], typingAnimation[0], fallingAnimation[0]],
    avatarRef
  );

  const [isMobile] = useIsMobile();
  const [currentAnimation, setCurrentAnimation] = useCurrentAnimation();
  const [currentSection] = useCurrentSection();

  const { viewport } = useThree();

  const lastAnimationRef = useRef(currentAnimation);
  useEffect(() => {
    if (currentAnimation !== lastAnimationRef.current) {
      actions[currentAnimation]?.reset().fadeIn(0.5).play();
      lastAnimationRef.current = currentAnimation;
      return () => {
        actions[currentAnimation]?.reset().fadeOut(0.5);
      };
    }
  }, [currentAnimation]);
  const [isWireFrame, sewtIsWireFrame] = useIsWireFrame();

  useEffect(() => {
    switch (currentSection) {
      case 0:
        setCurrentAnimation("Typing");
        break;
      case 1:
        setCurrentAnimation("Falling");
        break;
      case 2:
        setCurrentAnimation("");
        break;
      case 3:
        setCurrentAnimation("Idle");
        break;
      case 4:
        setCurrentAnimation("Typing");
        break;
    }
    if (currentSection === 2) sewtIsWireFrame(true);
    else sewtIsWireFrame(false);
  }, [currentSection]);

  useFrame((state, delta) => {
    if (!avatarRef.current) return;
    if (currentSection === 2) {
      avatarRef.current.rotation.y -= delta;
    } else {
      if (avatarRef.current.rotation.y !== 0)
        avatarRef.current.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    }
  });

  useEffect(() => {
    Object.values(materials).forEach((material) => {
      material.wireframe = isWireFrame;
    });
    // console.log(nodes);
  }, [isWireFrame]);

  const avatarVariants: Variants = {
    section_0: {
      x: isMobile ? viewport.width / 2.5 : viewport.width / 8,
      y: -viewport.height / 3,
      z: 0,
    },
    section_1: {
      x: 0,
      y: -viewport.height / 8,
      // y: -viewport.height * 1.125,
      z: 1,
    },
    section_2: {
      x: isMobile ? 0 : viewport.width / 8,
      y: -viewport.height / 8,
      // y: -viewport.height * 2.125,
      z: 3,
    },
    section_3: {
      x: -viewport.width / 4,
      // y: -viewport.height * 3,
      y: -viewport.height / 4,
      z: 0,
    },
    section_4: {
      x: viewport.width / 16,
      // y: -viewport.height * 4.15,
      y: -viewport.height / 6,
      z: 4,
    },
  };

  return (
    <motion.group
      variants={avatarVariants}
      animate={`section_${currentSection}`}
    >
      <group {...props} dispose={null} ref={avatarRef}>
        <primitive object={nodes.Hips} />
        <skinnedMesh
          castShadow
          receiveShadow
          name="EyeLeft"
          geometry={nodes.EyeLeft.geometry}
          material={materials.Wolf3D_Eye}
          skeleton={nodes.EyeLeft.skeleton}
          morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
          morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
          frustumCulled={false}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          name="EyeRight"
          geometry={nodes.EyeRight.geometry}
          material={materials.Wolf3D_Eye}
          skeleton={nodes.EyeRight.skeleton}
          morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
          morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
          frustumCulled={false}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          name="Wolf3D_Head"
          geometry={nodes.Wolf3D_Head.geometry}
          material={materials.Wolf3D_Skin}
          skeleton={nodes.Wolf3D_Head.skeleton}
          morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
          morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
          frustumCulled={false}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          name="Wolf3D_Teeth"
          geometry={nodes.Wolf3D_Teeth.geometry}
          material={materials.Wolf3D_Teeth}
          skeleton={nodes.Wolf3D_Teeth.skeleton}
          morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
          morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
          frustumCulled={false}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          geometry={nodes.Wolf3D_Body.geometry}
          material={materials.Wolf3D_Body}
          skeleton={nodes.Wolf3D_Body.skeleton}
          frustumCulled={false}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
          material={materials.Wolf3D_Outfit_Bottom}
          skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
          frustumCulled={false}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
          material={materials.Wolf3D_Outfit_Footwear}
          skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
          frustumCulled={false}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          geometry={nodes.Wolf3D_Outfit_Top.geometry}
          material={materials.Wolf3D_Outfit_Top}
          skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
          frustumCulled={false}
        />
        <skinnedMesh
          castShadow
          receiveShadow
          geometry={nodes.Wolf3D_Hair.geometry}
          material={materials.Wolf3D_Hair}
          skeleton={nodes.Wolf3D_Hair.skeleton}
          frustumCulled={false}
        />
      </group>
    </motion.group>
  );
}

useGLTF.preload("/models/avatar.glb");
